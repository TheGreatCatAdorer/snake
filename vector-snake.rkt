#lang racket/base
(define (grid edge)
  (make-vector (expt edge 2) #\0))
(define (direction-helper weights direction)
  (if (< direction 3)
    (if (<= (random) (car weights))
      direction
      (direction-helper (cdr weights) (add1 direction)))
    3))
(define (universal-weights values) (make-vector 16 values))
(define default-weights (universal-weights (list 1/4 1/3 1/2)))
(define (format vec edge)
  (define (format-helper lst edge acc i)
    (if (equal? lst '()) acc
      (format-helper (cdr lst) edge
        (if (equal? (modulo i edge) (sub1 edge)) (cons #\newline (cons (car lst) acc)) (cons (car lst) acc)) (add1 i))))
  (list->string (format-helper (vector->list vec) edge '() 0)))
(define (snake edge weights)
  (let ((center (floor (/ edge 2))))
    (snake-helper (cons center center) edge (grid edge) weights 0)))
(define (snake-helper pos edge grid-path weights i)
  (if (< i 1000000)
    (let* ((posi (+ (* (cdr pos) edge) (car pos)))
           (seeker (lambda (x? +? x y)
                    (if (and (or x? +? (> (cdr pos) 0)) (or x? (not +?) (< (cdr pos) (sub1 edge))) (or (not x?) (not +?) (< (car pos) (sub1 edge))) (or (not x?) +? (> (car pos) 0)))
                      (string->number (string (vector-ref grid-path (+ x (car pos) (* edge (+ y (cdr pos)))))))
                      1))))
      (let ((up (seeker #f #f 0 -1))
            (down (seeker #f #t 0 1))
            (right (seeker #t #t 1 0))
            (left (seeker #t #f -1 0)))
        (let* ((movement (vector-ref weights (+ (* 8 up) (* 4 down) (* 2 right) left)))
               (direction (direction-helper movement 0))
               (pos1 (lambda (delta-x delta-y) (cons (+ (car pos) delta-x) (+ (cdr pos) delta-y))))
               (next (lambda (move pos2)
                       (if (equal? move 0)
                         (begin (vector-set! grid-path posi #\1) (snake-helper pos2 edge grid-path weights (add1 i)))
                         ;(snake-helper pos edge grid-path weights i)
                         ;(snake-helper pos edge grid-path weights (add1 i))
                         ;(begin (vector-set! grid-path posi #\X) (display (list i pos (format grid-path edge))))
                         (format grid-path edge)
                         ;(cons i pos)
                         ))))
          (cond ((equal? direction 0) (next up (pos1 0 -1)))
                ((equal? direction 1) (next down (pos1 0 1)))
                ((equal? direction 2) (next right (pos1 1 0)))
                ((equal? direction 3) (next left (pos1 -1 0)))))))
    (cons i pos)))
(for ((i (in-range 0 100000)))
  (snake 64 default-weights))
(display (snake 32 default-weights))